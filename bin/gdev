#!/usr/bin/env ruby
require 'open3'
require 'yaml'
require 'json'

class DevTool
  MAIN_HELP_BANNER = <<HEREDOC
Execute various commands within the developer environment

Usage:
  dev [options] [COMMAND] [ARGS...]"
  dev -h|--help

Options:
  --verbose                 Show more output
  -v, --version             Print version and exit

Commands:
  build              Build or rebuild services
  cleanup           Deletes docker containers, images and volumes
  exec               Run command inside web container
  help               Get help on a command
  kill               Kill containers
  logs               View output from containers
  ps                 List containers
  pull               Pulls service images
  restart            Restart services
  reload             Force recreates all services
  rm                 Remove stopped containers
  run                Run a one-off command
  shell              Open shell inside container
  service            Manage gdev services (nginx and dnsmasq, mail)
  start              Start services
  stop               Stop services
  up                 Create and start containers
  update             Update gdev environment
  sync               Syncronize files with data container

HEREDOC

  PROXY_UNMODIFIED_TO_COMPOSE=%w{build kill logs ps pull restart rm start stop}
  PROXY_MODIFIED=%w{up run}
  OTHER_COMMANDS=%w{wait reload cleanup machine update service status shell exec sync}

  def initialize(args)
    if PROXY_UNMODIFIED_TO_COMPOSE.include?(args[0])
      system(args.unshift("docker-compose").join(" "))
    elsif PROXY_MODIFIED.include?(args[0])
      send(args[0].to_sym, args)
    elsif OTHER_COMMANDS.include?(args[0])
      send(args.shift.to_sym, args)
    else
      puts MAIN_HELP_BANNER
    end
  end

  def run(args)
    args.insert(1, "--rm")
    args.unshift("docker-compose")
    system(args.join(" "))
  end

  def reload(args)
    service(["up"])

    args.unshift("-d")
    args.unshift("--force-recreate")
    args.unshift("up")
    args.unshift("docker-compose")

    system(args.join(" "))

    after_reload()

    # Output information about unison or bg-sync
    settings = get_container_settings()
    if not settings['unison'].nil? and not settings['unison'].empty?
        if settings['unison']['image'] == 'onnimonni/unison'
            puts "INFO: To sync file changes in realtime to data container use $ gdev sync"
        elsif settings['unison']['image'] == 'devgeniem/bg-sync'
            # Wait for bg-sync to be finished
            wait([])
        end
    end
  end

  def cleanup(args)

    if args.include?('--images')

        puts "Removing all unused docker images..."
        images = `docker images -q`.gsub("\n",' ')

        system "docker rmi #{images}" if $?.success? and not images.empty?

    elsif args.empty?

        puts "Removing exited docker containers..."

        containers = `docker ps -a -q -f status=exited`.gsub("\n",' ')

        system "docker rm -v #{containers}" if $?.success? and not containers.empty?

        puts "Removing dangling docker images..."

        images = `docker images -f 'dangling=true' -q`.gsub("\n",' ')

        system "docker rmi #{images}" if $?.success? and not images.empty?

        puts "Removing dangling docker volumes..."

        volumes = `docker volume ls -qf dangling=true`.gsub("\n",' ')

        system "docker volume rm #{volumes}" if $?.success? and not volumes.empty?

    end

  end

  def up(args)
    service(["up"])

    # Run startup scripts
    before_up()

    args.insert(1, "-d")
    args.unshift("docker-compose")
    system(args.join(" "))

    # Output information about unison or bg-sync
    settings = get_container_settings()
    if not settings['unison'].nil? and not settings['unison'].empty?
        if settings['unison']['image'] == 'onnimonni/unison'
            puts "INFO: To sync file changes in realtime to data container use $ gdev sync"
        elsif settings['unison']['image'] == 'devgeniem/bg-sync'
            # Wait for bg-sync to be finished
            wait([])
        end
    end

  end

  def wait(args)

    if command_exists 'du'

        settings = get_container_settings()
        if is_osx?
            puts "INFO: Waiting for initial host <-> container filesystem sync..."
            print "Progress:"
            last_text = ""
            30.times do # 30 * 2 is good enough timeout for the process
                host_data_amount = `du -I '.git' -I '.docker' -sm #{settings['unison']['source']} | cut -f1`.strip
                container_data_amount = `gdev run #{settings['unison']['container_name']} du -sm #{settings['unison']['destination']} | cut -f1`.strip

                # Only show minimal progress bar if text didn't change from the last time
                percent = ( container_data_amount.to_f / host_data_amount.to_f * 100 ).round(2)

                # This is only approximation but it's close enough
                # Usually the data generated by container makes this calculation go south
                if host_data_amount.to_i - container_data_amount.to_i < 20 or container_data_amount.to_f / host_data_amount.to_f  > 0.98
                    print "\n#{host_data_amount}M / #{host_data_amount}M - 100%\n"
                    sleep 1
                    puts "INFO: Initial sync is ready!"
                    return true
                end

                new_text = "#{container_data_amount.rjust(host_data_amount.length, ' ')}M / #{host_data_amount}M - #{percent}% "
                if last_text == new_text
                    print '.'
                else
                    print "\n#{new_text}"
                end

                sleep 3
                last_text = new_text
            end
            puts "ERROR: Sync process timeout..."
            return false
        end
    end
  end

  # open shell into container
  def shell(args)
    container=`docker-compose ps -q web`.strip
    system("docker exec -it #{container} bash")
  end

  # Run command in web container
  def exec(args)
    container=`docker-compose ps -q web`.strip
    system "docker exec -it #{container} #{args.join(' ')}"
  end

  # Updating is just running bootstrap again with newer bootstrap bin
  def update(args)
    if (args[0].nil?)
      system('cd /usr/local/gdev-env && git reset HEAD --hard && git pull origin HEAD && bin/bootstrap')
      # Rebuild and reload all services
      puts "Refreshing all gdev services..."
      service(['build nginx'])
      service(['reload'])
    else
      puts "Did you mean to run: $ gdev update ?"
    end
  end

  def service(args)
    if (args[0] == "reload")
      args[0] = "up"
      args.push("--force-recreate")
    end
    if (args[0] == "up")
      args.push("-d")
    elsif (args[0].nil?)
      no_command_given = true
    end
    args.unshift("docker-compose", "-f /usr/local/gdev-env/docker/services.yml", "-p gdev")
    box_ip="10.254.254.254"
    # Set system variables which we can use in our templates
    system({"BOX_IP" => box_ip},args.join(" "))

    # Tell about custom commands if help view was shown
    if (no_command_given)
      puts "  reload             Force updates all service containers"
    end
  end

  # Syntactic sugar for: $ gdev ps
  # I want this to look like vagrant binary
  def status(args)
    system("docker-compose ps")
  end

  # If docker-compose has container using onnimonni/unison container run that one first and sync
  def before_up()
    settings = get_container_settings()

    if settings['unison'] and settings['unison']['image'] == 'onnimonni/unison'

      # Start data container
      system("docker-compose up -d #{settings['unison']['container_name']}")
      # Give the container a moment to start
      sleep 1

      # Sync with the started container
      sync([ settings['unison']['container_name'], '-once', '-silent'] )

    end

    return settings
  end

  def after_reload()
    settings = get_container_settings()

    if not settings['unison'].nil? and settings['unison']['image'] == 'onnimonni/unison' and not settings['unison']['port'].nil?
      # Sync with the started container
      sync([ settings['unison']['container_name'], '-once', '-silent'] )
    end
  end

  def get_container_settings()

    settings = {}
    config_string = `docker-compose config`
    if File.exist?('docker-compose.yml') and not config_string.empty?
        config = YAML.load(config_string)

        # If the docker-compose includes any unison containers sync with them
        config['services'].each do |container_name,data|

            if not data['image'].nil? and not data['image'].empty?

                # onnimonni/unison is legacy, but preserve it for older projects
                # devgeniem/bg-sync is newer way but it does need some help for outputting it's progress
                if not data['ports'].nil? and data['image'].include? 'onnimonni/unison'

                    settings = { 'unison' => { 'container_name' => container_name, 'image' => 'onnimonni/unison' } }

                    port = get_docker_host_port(container_name)
                    settings['unison']['port'] = port unless port.nil?

                elsif data['image'].include? 'devgeniem/bg-sync'
                    # Take the absolute path for the host machine volume source
                    volume = data['volumes'].select { |volume| volume.include?(':/source') }.first
                    if volume
                        source = volume.split(':').first
                    else
                        source = nil
                    end
                    settings = { 'unison' => {
                        'container_name' => container_name,
                        'image' => 'devgeniem/bg-sync',
                        'destination' => data['environment']['SYNC_DESTINATION'],
                        'source' => source # This is the volume path in host machine
                    } }

                end

            end
        end
    end

    return settings

  end

  def get_docker_host_port(container_name)
    # Get the data container id
    data_docker_id=`docker-compose ps -q #{container_name}`
    if $?.success? and not data_docker_id.empty?
        # Get the data container port
        data_docker_ports = %x(docker inspect --format='{{json .NetworkSettings.Ports}}' #{data_docker_id})
        if $?.success? and data_docker_ports
            begin
                data_docker_ports_obj = JSON.parse(data_docker_ports)
                data_docker_host_port = data_docker_ports_obj["5000/tcp"][0]['HostPort']
                port = data_docker_host_port
                return port
            rescue JSON::ParserError
                # Container wasn't yet started
                return nil
            end
        end
    end
    return nil
  end

  def sync(args)

    unless File.exist?('docker-compose.yml')
        puts "ERROR: docker-compose.yml doesn't exist. You need to run this command in the project root."
        exit
    end

    options = ['-auto', '-batch', '-prefer newer']
    ignore = ['.git', '.docker','*.unison.tmp']
    container_name = 'data'

    # Repeat unless user provided -norepeat or -once flag
    if args.include?('-norepeat') or args.include?('-once')
      # Delete the pseudo options
      args.delete('-norepeat')
      args.delete('-once')

    # Else use repeat option if system includes dependency unison-fsmonitor
    elsif command_exists('unison-fsmonitor')
      options.push('-repeat watch')
    end

    # If args contains option without - in the beginning override container_name with that
    args.each { |arg|
        if arg.chars[0] != '-'
            container_name = arg
            args.delete(container_name)
        end
    }

    options += ignore.collect { |item| "-ignore 'Path #{item}'" }

    port = get_docker_host_port(container_name)

    puts "INFO: Starting to sync into port: #{port}..."

    unison_args = ( options | args ).join(' ')

    # Really no output please
    if args.include?('-silent')
      unison_args << ' > /dev/null'
    end

    system "UNISONLOCALHOSTNAME=dev-machine unison . socket://localhost:#{port}/ #{unison_args}"

    puts "INFO: Sync is ready!"
  end

  def is_osx?
    RUBY_PLATFORM.include? 'darwin'
  end

  # Cross-platform way of finding an executable in the $PATH.
  #
  #   which('ruby') #=> /usr/bin/ruby
  def command_exists(cmd)
    exts = ENV['PATHEXT'] ? ENV['PATHEXT'].split(';') : ['']
    ENV['PATH'].split(File::PATH_SEPARATOR).each do |path|
      exts.each { |ext|
        exe = File.join(path, "#{cmd}#{ext}")
        return exe if File.executable?(exe) && !File.directory?(exe)
      }
    end
    return nil
  end
end

DevTool.new(ARGV) if __FILE__==$0
