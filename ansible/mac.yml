---
- hosts: 127.0.0.1
  connection: local

  vars:
    gdev_env_dir: /usr/local/gdev-env
    gdev_user_files: "{{ansible_env.HOME}}/.gdev"

  tasks:

    - name: Check Sudo Password
      shell: echo "Sudo password works"
      become: yes
      become_method: sudo

    - name: Install Docker and Extras
      homebrew:
        name: "{{ item }}"
        state: latest
      with_items:
        - docker
        - docker-compose
        - dlite
      tags: ['pre-install']

    - name: Create gdev directory
      file:
        path: "{{ansible_env.HOME}}/.gdev"
        state: directory
        mode: 0755

    - name: Symlink gdev bin to PATH
      file:
        src: "{{gdev_env_dir}}/bin/gdev"
        dest: /usr/local/bin/gdev
        state: link
      tags: ['pre-install']

    # This is a small hacky check to tell users to avoid colliding paths with dlite
    - name: Check how many nfs mounts exist in /Users/ path
      shell: grep '/Users' /etc/exports | wc -l | xargs
      register: nfs_mount_count
      tags: ['pre-install']

    - name: Fail if user has any nfs mounts in /Users/
      fail: msg="Dlite doesn't work with other processes using /Users through nfs. Please use different mountpoint for other processes like Vagrant instead"
      when: nfs_mount_count is defined and nfs_mount_count.stdout|int > 1
      tags: ['pre-install']

    - name: Check if dlite is installed
      stat:
        path: "{{ansible_env.HOME}}/.dlite/config.json"
      register: dlite_installed

    - name: Ask user to install dlite manually if dlite is not installed
      fail:
        msg: "Try to install dlite manually: $ sudo dlite install --os-version={{ dlite_version }} --share={{ansible_env.HOME}}"
      when: not dlite_installed.stat.exists

    - name: "Check that we have /var/run/docker.sock socket"
      stat: path=/var/run/docker.sock
      register: docker_socket

    - name: Fail if no docker.sock
      fail: msg="Dlite didn't mount /var/run/docker.sock try start/reinstalling dlite..."
      when: not docker_socket.stat.exists

    - name: Get machine ip address
      shell: "{{ gdev_env_dir }}/bin/gdev machine ip"
      register: machine_ip
      ignore_errors: yes

    - name: Fail if gdev machine didn't return ip
      fail: msg="Dlite doesn't return ip. Please try to reboot your computer and then rerun this command"
      when: machine_ip.stdout == ""

    - name: "Debug dlite ip"
      debug:
        msg: "Dlite is up and running: {{ machine_ip.stdout }}"

    - name: Start gdev services
      command: "{{ gdev_env_dir }}/bin/gdev service up"

    - name: Wait for signaler to create CA file
      wait_for:
        path: "{{ gdev_user_files }}/ca/ca.crt"
        state: present
        timeout: 30

    # This only works in OS X and doesn't affect firefox
    # We want to use https locally and you only use ca.key which is generated to you
    - name: Trust self-generated signaler Root certificate in keychain
      shell: "security add-trusted-cert -d -r trustRoot -k '/Library/Keychains/System.keychain' ca.crt"
      args:
        chdir: "{{ gdev_user_files }}/ca/"
      become: yes
      become_method: sudo

    - name: Create resolver directory
      file: path=/etc/resolver state=directory mode=0755
      become: yes
      become_method: sudo

    - name: Delete resolver files to trigger dns change
      file:
        path: "/etc/resolver/{{item.domain}}"
        state: absent
      become: yes
      become_method: sudo
      with_items:
        - { ip: "{{ machine_ip.stdout }}", domain: test }

    - name: Create dns resolver files at /etc/resolver/
      template:
        src: "{{ gdev_env_dir }}/ansible/resolver-dev.conf.j2"
        dest: "/etc/resolver/{{item.domain}}"
        force: yes
      become: yes
      become_method: sudo
      with_items:
        - { ip: "{{ machine_ip.stdout }}", domain: test }
